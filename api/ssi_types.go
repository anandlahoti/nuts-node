// Package ssiTypes provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package ssiTypes

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Subject of a Verifiable Credential identifying the holder and expressing claims.
type CredentialSubject = interface{}

// DID according to Nuts specification
type DID = string

// Cryptographic proofs that can be used to detect tampering and verify the authorship of a
// credential or presentation. An embedded proof is a mechanism where the proof is included in
// the data, such as a Linked Data Signature.
type EmbeddedProof struct {
	// A random or pseudo-random value, provided by the verifier, used by some authentication protocols to
	// mitigate replay attacks.
	Challenge *string `json:"challenge,omitempty"`

	// Date and time at which proof has been created.
	Created string `json:"created"`

	// A string value that specifies the operational domain of a digital proof. This could be an Internet domain
	// name like example.com, an ad-hoc value such as mycorp-level3-access, or a very specific transaction value
	// like 8zF6T$mqP. A signer could include a domain in its digital proof to restrict its use to particular
	// target, identified by the specified domain.
	Domain *string `json:"domain,omitempty"`

	// JSON Web Signature
	Jws string `json:"jws"`

	// A unique string value generated by the holder, MUST only be used once for a particular domain
	// and window of time. This value can be used to mitigate replay attacks.
	Nonce *string `json:"nonce,omitempty"`

	// It expresses the purpose of the proof and ensures the information is protected by the
	// signature.
	ProofPurpose string `json:"proofPurpose"`

	// Type of the object or the datatype of the typed value. Currently only supported value is "JsonWebSignature2020".
	Type string `json:"type"`

	// Specifies the public key that can be used to verify the digital signature.
	// Dereferencing a public key URL reveals information about the controller of the key,
	// which can be checked against the issuer of the credential.
	VerificationMethod string `json:"verificationMethod"`
}

// A credential according to the W3C and Nuts specs.
type VerifiableCredential struct {
	// List of URIs of JSON-LD contexts of the VC.
	Context interface{} `json:"@context"`

	// Subject of a Verifiable Credential identifying the holder and expressing claims.
	CredentialSubject CredentialSubject `json:"credentialSubject"`

	// rfc3339 time string until when the credential is valid.
	ExpirationDate *string `json:"expirationDate,omitempty"`

	// Credential ID. An URI wich uniquely identifies the credential e.g. the issuers DID concatenated with an uuid.
	Id *string `json:"id,omitempty"`

	// rfc3339 time string when the credential was issued.
	IssuanceDate string `json:"issuanceDate"`

	// DID according to Nuts specification
	Issuer DID `json:"issuer"`

	// one or multiple cryptographic proofs
	Proof interface{} `json:"proof"`

	// A single string or array of strings. The value(s) indicate the type of credential. It should contain `VerifiableCredential`. Each type should be defined in the @context.
	Type []string `json:"type"`
}

// Verifiable Presentation
type VerifiablePresentation struct {
	// An ordered set where the first item is a URI https://www.w3.org/2018/credentials/v1. It is used to define
	// terms and help to express specific identifiers in a compact manner.
	Context interface{} `json:"@context"`

	// URI of the entity that is generating the presentation.
	Holder *string `json:"holder,omitempty"`

	// URI that is used to unambiguously refer to an object, such as a person, product, or organization.
	Id *string `json:"id,omitempty"`

	// Cryptographic proofs that can be used to detect tampering and verify the authorship of a
	// credential or presentation. An embedded proof is a mechanism where the proof is included in
	// the data, such as a Linked Data Signature.
	Proof *interface{} `json:"proof,omitempty"`

	// A single string or array of strings. Values indicate the type of object. It should contain `VerifiablePresentation`. Each type must be defined in the @context.
	Type interface{} `json:"type"`

	// VerifiableCredential is composed of a list containing one or more verifiable credentials, in a
	// cryptographically verifiable format.
	VerifiableCredential *interface{} `json:"verifiableCredential,omitempty"`
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
